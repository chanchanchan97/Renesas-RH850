//============================================================================
// PROJECT  :  F1L StarterKit
//============================================================================
//                           C O P Y R I G H T
//============================================================================
// Copyright (c) 2013 by Renesas Electronics  GmbH. All rights reserved.
// Arcadiastr.10
// D-40472 Duesseldorf
// Germany
//============================================================================
//
// Warranty Disclaimer :
// Because the Product(s) is licensed free of charge, there is no warranty of
// any kind whatsoever and expressly disclaimed and excluded by Renesas, either
// expressed or implied, including but not limited to those for non-
// infringement of intellectual property, merchantability and/or fitness for
// the particular purpose. Renesas shall not have any obligation to maintain,
// service or provide bug fixes for the supplied Product(s) and/or the
// Application.
//
// Each User is solely responsible for determining the appropriateness of
// using the Product(s) and assumes all risks associated with its exercise
// of rights under this Agreement, including, but not limited to the risks
// and costs of program errors, compliance with applicable laws, damage to
// or loss of data, programs or equipment, and unavailability or
// interruption of operations.
//
// Limitation of Liability :
// In no event shall Renesas be liable to the User for any incidental,
// consequential, indirect, or punitive damage (including but not limited to
// lost profits) regardless of whether such liability is based on breach of
// contract, tort, strict liability, breach of warranties, failure of
// essential purpose or otherwise and even if advised of the possibility of
// such damages. Renesas shall not be liable for any services or products provided
// by third party vendors, developers or consultants identified or referred
// to the User by Renesas in connection with the Product(s) and/or the
// Application.
//
//============================================================================
//
// Source code for the UART Functions
//
//============================================================================

//============================================================================
// Includes
//============================================================================
//#include "device.h"
#include "rlin30.h"
#include "iodefine.h"

//============================================================================
// Variables
//============================================================================
volatile unsigned char Trans_num, Recep_num, Stat_num;
volatile unsigned char Reception_ID, Slave_checksum, Checked_ID;
volatile unsigned char byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8;
volatile unsigned char Current_state = 0;
volatile unsigned char ERelay_Error, ERelay_St, ERelay_PrimaryVoltage, ERelay_SecondaryVoltage, ERelay_Current, ERelay_ResponseError;


enum
{
    Res_Trans_Completed = 1,
    Header_0x28_Recep_Completed,
    Header_0x29_Recep_Completed,
    Res_Recep_Completed,
}
State;   

//============================================================================
// Functions
//============================================================================
/******************************************************************************
** Function:    INTRLIN30UR0
** Description: This interrupt is generated by the LIN Slave interface
**              It creates a call back in the Tasks source
** Parameter:   None
** Return:      None
******************************************************************************/
/* This interrupt generates a CallBack in Task.c */
#pragma interrupt INTRLIN30UR0_interrupt( enable=false , channel=26 , callt=false , fpu=false )
void INTRLIN30UR0_interrupt( void )
{
    Trans_num++;
    
    
    if( (RLN30.LST & 0x01) == 0x01 )	//Response Transmission has been completed
    {
	Current_state = Res_Trans_Completed;
    }

    RFRLIN30UR0 = 0;    //Reset RLIN30UR0 InterruptRequestFlag
}

/******************************************************************************
** Function:    INTRLIN30UR1
** Description: This interrupt is generated by the LIN Slave interface
**              It creates a call back in the Tasks source
** Parameter:   None
** Return:      None
******************************************************************************/
/* This interrupt generates a CallBack in Task.c */
#pragma interrupt INTRLIN30UR1_interrupt( enable=false , channel=27 , callt=false , fpu=false )
void INTRLIN30UR1_interrupt( void )
{
    Recep_num++;
    
    Slave_checksum = RLN30.LCBR;

    if( (RLN30.LST & 0x80) == 0x80 )		//Header Reception has been completed
    {
        Reception_ID = RLN30.LIDB;
	RLN30.LST = 0x00;
	
	if( Reception_ID == PID_check( Reception_ID & 0x3f ) )	//check the bit of PID
	{
	    if( (Reception_ID & 0x3f) == 0x28 )		//while 0x28 header received, Response Reception start
	    {
	        Res_Recep_test();
		Current_state = Header_0x28_Recep_Completed;
	    }
	    else if( (Reception_ID & 0x3f) == 0x29 )	//while 0x29 header received, Response Transmission start 
	    {
	        Res_Trans_test();
		Current_state = Header_0x29_Recep_Completed;
	    }
	}
    }
    else if( (RLN30.LST & 0x02) == 0x02 )	//Response Reception has been completed
    {
	//Read data(8 bytes) from LIN data buffer register
        byte1 = RLN30.LDBR1;
        byte2 = RLN30.LDBR2;
        byte3 = RLN30.LDBR3;
        byte4 = RLN30.LDBR4;
        byte5 = RLN30.LDBR5;
        byte6 = RLN30.LDBR6;
        byte7 = RLN30.LDBR7;
        byte8 = RLN30.LDBR8;
	
	RLN30.LTRC = 0x01;	//Header Transmission start
	Current_state = Res_Recep_Completed;
    }

    RFRLIN30UR1 = 0;    //Reset RLIN30UR1 InterruptRequestFlag
}

/******************************************************************************
** Function:    INTRLIN30UR1
** Description: This interrupt is generated by the LIN Slave interface
**              It creates a call back in the Tasks source
** Parameter:   None
** Return:      None
******************************************************************************/
/* This interrupt generates a CallBack in Task.c */
#pragma interrupt INTRLIN30UR2_interrupt( enable=false , channel=28 , callt=false , fpu=false )
void INTRLIN30UR2_interrupt( void )
{
    Stat_num++;
    
    if( RLN30.LEST != 0x00 )
    	ERelay_ResponseError = 0x01;

    RFRLIN30UR2 = 0;    //Reset RLIN30UR2 InterruptRequestFlag
}

/******************************************************************************
** Function:    RLIN30_init
** Description: Initialize the RLIN30 for UART 
** Parameter:   None
** Return:      None
******************************************************************************/
void RLIN30_init(void)
{
  /* RLIN30 is configured in UART mode with 9600 baud*/
  
  /* Disable RLIN */ 
  RLN30.LUOER=0x00;
  RLN30.LCUC=0x00;
  
  
  /* IN Mode Register/UART Mode Register (LMD) */
  RLN30.LMD=0x01;      //UART mode
                      //LIN / UART System Clock: fa
                      //Module generates 1 interrupt signal
                      //3-bit majority voting logic for sampling RX data is enabled.
                
  /* LIN Break Field Configuration Register/UART Configuration Register1 */
  RLN30.LBFC=0x00;     //UART 8-bit communication
                      //LSB first
                      //Stop Bit 1 bit
                      //Parity Disabled
                      //Without RX inversion
                      //Without RX inversion
  
  /* LIN / UART Error Detection Enable Register */
  RLN30.LEDE=0x00;     //No error detection

  /* LIN Wake-up Baud Rate Selector register  */
  RLN30.LWBR=0x51;     //6 samples per bit  
                  
  
  /* LIN Baud Rate Prescaler1/UART Baud Rate Prescaler */
  RLN30.LBRP01.REGS8.LBRP1.UINT8=0x02;    //Baudrate = PCLK / (((BRP value) + 1)*(number of samples per bit)).
  RLN30.LBRP01.REGS8.LBRP0.UINT8=0xb5;    //40MHZ/((0x2b5+1)*6)= 9600 baud


  /* LIN / UART Control Register */
  RLN30.LCUC=0x01;     //Set SW Reset request to inactive


  /* UART Operation Enable Register */ 
  RLN30.LUOER=0x03;    //UART Transmission Operation Enable Bit
                       //UART Reception Operation Enable Bit
                     

}

/******************************************************************************
** Function:    RLIN30_port_init
** Description: Configures P0_2 to alternative function RLIN30TX
**              Configures P0_3 to alternative function RLIN30RX
** Parameter:   None
** Return:      None
******************************************************************************/
void RLIN30_port_init(void)
{
    
  /* Config RLIN30 Port Pins */ 
  /* RLIN30 TX on PIN 2 of Port 0 */
  PMC0  |= 1 << 2;
  PFCE0 &= ~(1 << 2);
  PFC0  |= (1 << 2);
  PFCAE0&= ~(1 << 2);
  PM0   &= ~(1 << 2);
    
  /* RLIN30 RX on PIN 3 of Port 0 */
  PMC0  |= 1 << 3;
  PFCE0 &= ~(1 << 3);
  PFC0  |=  1 << 3;
  PFCAE0&= ~(1 << 3);
  PM0   |= 1 << 3;
}

/******************************************************************************
** Function:    RLIN30_send_string
** Description: Sends out a complete string via UART by using DirectMemoryAccess
** Parameter:   string to be send
** Return:      None
******************************************************************************/
void RLIN30_send_string( char send_string[] ) 
{

    unsigned short  us_string_length= 0x00;

    /* Calculate length of string send_string [] */
    while( send_string[ us_string_length ] != '\0' )
        ++us_string_length;
    
    /* Wait until transmission is finished */
    while((RLN30.LST&16)==16);
    
    /* Initialize DMA for sending bytes */
    while(DTS0DTE != 0);                     //Wait until last transmission is finished 
    
                                                    
    DTS0 = 0x00;                             //Disable DMA
    DTC0 = us_string_length-1;               //Number of times the DMA transfers(string length -1 because first trigger is manually given)
    DSA0 = (unsigned int)&send_string[1];    //Source Address = string buffer
    DDA0 = (unsigned int)&RLN30.LUTDR;        //Destination Address = RLIN transmit register
    DTCT0 = 0x0020;                          //8bit TransferSize / No Loop / Fixed Destination / Increment Source
    DTFR0 = 0x800a;                          //Trigger Enabled / Source = RLIN30 transmit interrupt
    DRQCLR = 1;                              //Clear DMA channel 0 request 
    DTS0 |= 0x01;                            //Enable DMA channel 0 transfer
    
    /* Start transmission */
    RLN30.LUTDR.UINT16 = send_string[0];     //Write first char to RLIN transmit register to start transmission
  
}

/******************************************************************************
** Function:    RLIN30_get_status
** Description: Returns if RLIN30 is busy or ready
** Parameter:   None
** Return:      RLIN30_busy
**              RLIN30_ready
******************************************************************************/
enum RLIN30_status RLIN30_get_status()
{
    if((RLN30.LST&16)==16)		//If transmission bit is set
    {
        return RLIN30_busy;		//Return RLIN30 is busy
    }
    else				//If transmission bit is 0 (transmission ready)
    {
        return RLIN30_ready;		//Return RLIN30 is ready
    }
}

/******************************************************************************
** Function:    RLIN30_init2
** Description: Initialize the RLIN30 for LIN 
** Parameter:   None
** Return:      None
******************************************************************************/
void RLIN30_init2(void)
{
  /* Reset is caused */ 
  do
  {
      RLN30.LCUC = 0x00;
  }while(RLN30.LMST != 0x00);
  
  /* LIN Mode Register */
  RLN30.LMD = 0x13;	//LIN Slave Mode
  			//RLIN3n transmission interrupt, RLIN3n successful reception interrupt, 
  			//and RLIN3n reception status interrupt are used
			//The noise filter is enabled
                
  /* LIN Break Field Configuration Register */
  RLN30.LBFC=0x00;     	//Low-level width of 9.5 Tbits or longer is detected
  
  /* LIN Error Detection Enable Register */
  RLN30.LEDE=0xff;     	//Error detection is enabled

  /* LIN Wake-up Baud Rate Selector register  */
  RLN30.LWBR=0x01;     	//16 samples per bit / Prescaler Clock is 1/2                 
  
  /* LIN Baud Rate Prescaler1/UART Baud Rate Prescaler */
  RLN30.LBRP01.REGS8.LBRP1.UINT8=0x00;	//Baudrate = PCLK / (((BRP value) + 1)*(number of samples per bit)).
  RLN30.LBRP01.REGS8.LBRP0.UINT8=0x81;	//40MHZ * 1/2 /((0x0081+1) * 16)= 9600 baud
  
  /* LIN Interrupt Enable Register */
  RLN30.LIE = 0x0f;	//LIN Interrupt is enabled.
  
  MKRLIN30UR0 = 0;	//Interrupt is unmasked by setting the mask bit to 0
  TBRLIN30UR0 = 1;	//Table interrupt is enabled by setting the table bit to 1
  ICRLIN30UR0L = 0x40;
  
  MKRLIN30UR1 = 0;	//Interrupt is unmasked by setting the mask bit to 0
  TBRLIN30UR1 = 1;	//Table interrupt is enabled by setting the table bit to 1
  ICRLIN30UR1L = 0x40;
  
  MKRLIN30UR2 = 0;	//Interrupt is unmasked by setting the mask bit to 0
  TBRLIN30UR2 = 1;	//Table interrupt is enabled by setting the table bit to 1
  ICRLIN30UR2L = 0x40;
  
  /* LIN Space Configuration Register */
  RLN30.LSC = 0x17;	//Inter-byte(header/response) 7Tbits and interbyte 1Tbit
  
  /* Reset is cancelled / operating mode is caused */ 
  do{
      RLN30.LCUC = 0x03;
  }while(RLN30.LMST != 0x03); 
  
  RLN30.LTRC = 0x01;

}

/******************************************************************************
** Function:    RLIN30_port_init2
** Description: Configures P10_9 to alternative function RLIN30RX
**              Configures P10_10 to alternative function RLIN30TX
** Parameter:   None
** Return:      None
******************************************************************************/
void RLIN30_port_init2(void)
{
    
  /* Config RLIN30 Port Pins */ 
  /* RLIN30 TX on PIN 10 of Port 10 */
  PMC10  |= 1 << 10;
  PFCE10 &= ~(1 << 10);
  PFC10  |= (1 << 10);
  PFCAE10&= ~(1 << 10);
  PM10   &= ~(1 << 10);
    
  /* RLIN30 RX on PIN 9 of Port 10 */
  PMC10  |= 1 << 9;
  PFCE10 &= ~(1 << 9);
  PFC10  |=  1 << 9;
  PFCAE10&= ~(1 << 9);
  PM10   |= 1 << 9;
}

/******************************************************************************
** Function:    Res_Trans_test
** Description: Starts the RLIN30 response transmission
** Parameter:   None
** Return:      None
******************************************************************************/
void Res_Trans_test(void)
{
    RLN30.LDFC = 0x38;	//Response field length 8byte + checksum, Response direction is Transmission
    
    /* Fill LIN data buffer register */
    RLN30.LDBR1 = 0x00;    
    RLN30.LDBR2 = 0x00;    
    RLN30.LDBR3 = 0x00;
    RLN30.LDBR4 = 0x00;
    RLN30.LDBR5 = 0x00;
    RLN30.LDBR6 = 0x00;
    RLN30.LDBR7 = 0x00;
    RLN30.LDBR8 = 0x00;
    
    RLN30.LTRC |= 0x02;	//Response Transmission start
}

/******************************************************************************
** Function:    Res_Recep_test
** Description: Starts the RLIN30 response reception
** Parameter:   None
** Return:      None
******************************************************************************/
void Res_Recep_test(void)
{
    RLN30.LDFC = 0x28;	//Response field length 8byte + checksum, Response direction is Reception
    
    RLN30.LTRC |= 0x02;	//Response Reception start
}

/******************************************************************************
** Function:    PID_check
** Description: check the bit P0 and P1 according to the frame ID
** Parameter:   Frame_ID
** Return:      8 bit protected Identifier
******************************************************************************/
unsigned char PID_check(unsigned char Frame_ID)
{
  unsigned char Protected_ID = 0x00;
  unsigned char PID_P0 = 0x00;
  unsigned char PID_P1 = 0x00;
  
  PID_P0 = (Frame_ID ^ (Frame_ID >> 1) ^ (Frame_ID >> 2) ^ (Frame_ID >> 4)) & 0x01;
  PID_P1 = ~((Frame_ID >> 1) ^ (Frame_ID >> 3) ^ (Frame_ID >> 4) ^ (Frame_ID >> 5) & 0x01);
  
  Protected_ID = (PID_P1 << 7) | (PID_P0 << 6) | Frame_ID;
  
  return Protected_ID;
}

